<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>educe - 2D Metroidvania</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body, html {
      width: 100%;
      height: 100%;
      background-color: #000;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
      background-color: #000;
    }
    
    #editor-ui {
      position: fixed;
      top: 10px;
      left: 10px;
      color: white;
      font-family: monospace;
      font-size: 14px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 4px;
      z-index: 1000;
      pointer-events: none;
      display: none;
    }
    
    #debug-info {
      position: fixed;
      bottom: 10px;
      left: 10px;
      color: white;
      font-family: monospace;
      font-size: 12px;
      background: rgba(0,0,0,0.7);
      padding: 8px;
      border-radius: 4px;
      z-index: 1000;
      pointer-events: none;
      display: none;
    }
    
    #game-menu {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-family: monospace;
      font-size: 14px;
      background: rgba(0,0,0,0.9);
      padding: 30px;
      border-radius: 8px;
      z-index: 2000;
      text-align: center;
      border: 2px solid #444;
    }
    
    #game-menu h2 {
      margin-bottom: 20px;
      font-size: 24px;
      color: #4CAF50;
    }
    
    #game-menu button {
      display: block;
      width: 200px;
      margin: 8px auto;
      padding: 10px 16px;
      background: rgba(76,175,80,0.8);
      color: white;
      border: 2px solid #4CAF50;
      border-radius: 4px;
      cursor: pointer;
      font-family: monospace;
      font-size: 14px;
      font-weight: bold;
      transition: all 0.2s;
    }
    
    #game-menu button:hover {
      background: #4CAF50;
      transform: scale(1.05);
    }
    
    #audio-controls {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid #444;
    }
    
    #audio-controls > div {
      margin: 10px 0;
    }
    
    #audio-controls input[type="range"] {
      width: 150px;
      margin: 0 10px;
    }
    
    #audio-controls button {
      width: auto;
      display: inline-block;
      margin: 4px;
      padding: 6px 12px;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <canvas id="screen"></canvas>
  
  <div id="editor-ui">
    <div><strong>EDITOR MODE</strong></div>
    <div>Mode: <span id="editor-mode">Tiles</span></div>
    <div>Selected Tile: <span id="selected-tile">1</span></div>
    <div>Room NPCs: <span id="room-npc-count">0</span></div>
  <div>WASM NPC Count: <span id="wasm-npc-count">0</span></div>
  <div>Last NPC Debug: <span id="npc-debug" style="display:inline-block; min-width:140px;">n/a</span></div>
    <div>Press 0-9 to select tile</div>
    <div>Press N to toggle NPC mode</div>
    <div>Click to paint tiles / place NPCs</div>
    <div>Ctrl+S to save</div>
    <div>Press E to exit editor</div>
  </div>
  
  <div id="debug-info">
    <div id="debug-text"></div>
  </div>
  
  <div id="game-menu">
    <h2>EDUCE</h2>
    <button id="resume-btn">Resume Game</button>
    <div id="audio-controls">
      <div><strong>Audio Controls</strong></div>
      <div>
        <button id="play-midi">▶ Play Music</button>
        <button id="stop-midi">⏸ Stop Music</button>
      </div>
      <div>
        BGM Volume:
        <button id="bgm-vol-down">-</button>
        <input id="bgm-volume" type="range" min="0" max="100" value="30" />
        <button id="bgm-vol-up">+</button>
      </div>
      <div id="bgm-volume-display">BGM: 30%</div>
      <div>
        SFX Volume:
        <button id="sfx-vol-down">-</button>
        <input id="sfx-volume" type="range" min="0" max="100" value="50" />
        <button id="sfx-vol-up">+</button>
      </div>
      <div id="sfx-volume-display">SFX: 50%</div>
    </div>
  </div>

  <script>
    window.RUNTIME_CONFIG = {
      devTools: false,
      hotReload: false,
    };
  </script>
  <script type="module">
// Auto-generated by config.sh
const MEMORY_PAGES = 2;
const INPUT = 0x0000;
const NUM_INPUTS = 4;
const SPRITE_POS = 0x0008;
const SPRITE_X_OFFSET = 0;
const SPRITE_Y_OFFSET = 4;
const SPRITE_FACING = 0x0010;
const ROOM_X = 0x0014;
const ROOM_Y = 0x0018;
const FACING_RIGHT = 0;
const FACING_LEFT = 1;
const FACING_UP = 2;
const FACING_DOWN = 3;
const WIDTH = 320;
const HEIGHT = 180;
const ROOM_TILE_COLS = 40;
const ROOM_TILE_ROWS = 22;
const TILE_PIXEL_WIDTH = 8;
const TILE_PIXEL_HEIGHT = 8;
const WORLD_WIDTH = 16;
const WORLD_HEIGHT = 16;

// Auto-generated from MIDI file: bgm.mid
// Total notes: 194

const bgm_midi = [
  {start: 0.004, freq: 174.614, gain: 0.630, dur: 1.814}, // note 53, channel 0
  {start: 0.009, freq: 293.665, gain: 0.630, dur: 0.723}, // note 62, channel 0
  {start: 0.012, freq: 220.000, gain: 0.339, dur: 1.817}, // note 57, channel 0
  {start: 0.837, freq: 329.628, gain: 0.630, dur: 0.992}, // note 64, channel 0
  {start: 1.955, freq: 164.814, gain: 0.630, dur: 1.836}, // note 52, channel 0
  {start: 1.971, freq: 220.000, gain: 0.339, dur: 1.810}, // note 57, channel 0
  {start: 1.979, freq: 293.665, gain: 0.630, dur: 0.704}, // note 62, channel 0
  {start: 2.785, freq: 261.626, gain: 0.630, dur: 0.996}, // note 60, channel 0
  {start: 3.905, freq: 261.626, gain: 0.630, dur: 0.729}, // note 60, channel 0
  {start: 3.905, freq: 164.814, gain: 0.630, dur: 0.740}, // note 52, channel 0
  {start: 3.913, freq: 220.000, gain: 0.339, dur: 1.819}, // note 57, channel 0
  {start: 4.730, freq: 146.832, gain: 0.630, dur: 0.976}, // note 50, channel 0
  {start: 4.738, freq: 293.665, gain: 0.630, dur: 0.994}, // note 62, channel 0
  {start: 5.833, freq: 130.813, gain: 0.630, dur: 0.733}, // note 48, channel 0
  {start: 5.833, freq: 220.000, gain: 0.339, dur: 0.737}, // note 57, channel 0
  {start: 5.837, freq: 329.628, gain: 0.630, dur: 0.748}, // note 64, channel 0
  {start: 6.693, freq: 293.665, gain: 0.630, dur: 1.112}, // note 62, channel 0
  {start: 6.700, freq: 195.998, gain: 0.630, dur: 1.017}, // note 55, channel 0
  {start: 6.707, freq: 123.471, gain: 0.630, dur: 1.033}, // note 47, channel 0
  {start: 7.809, freq: 174.614, gain: 0.630, dur: 1.813}, // note 53, channel 0
  {start: 7.814, freq: 293.665, gain: 0.630, dur: 1.820}, // note 62, channel 0
  {start: 7.817, freq: 220.000, gain: 0.339, dur: 1.817}, // note 57, channel 0
  {start: 9.760, freq: 164.814, gain: 0.630, dur: 1.836}, // note 52, channel 0
  {start: 9.775, freq: 220.000, gain: 0.339, dur: 1.810}, // note 57, channel 0
  {start: 9.784, freq: 329.628, gain: 0.630, dur: 0.826}, // note 64, channel 0
  {start: 10.589, freq: 261.626, gain: 0.630, dur: 0.996}, // note 60, channel 0
  {start: 11.710, freq: 164.814, gain: 0.630, dur: 1.338}, // note 52, channel 0
  {start: 11.710, freq: 261.626, gain: 0.630, dur: 1.826}, // note 60, channel 0
  {start: 11.717, freq: 220.000, gain: 0.339, dur: 1.819}, // note 57, channel 0
  {start: 13.171, freq: 146.832, gain: 0.630, dur: 0.339}, // note 50, channel 0
  {start: 13.638, freq: 220.000, gain: 0.339, dur: 0.874}, // note 57, channel 0
  {start: 13.638, freq: 130.813, gain: 0.630, dur: 1.484}, // note 48, channel 0
  {start: 13.642, freq: 293.665, gain: 0.630, dur: 1.846}, // note 62, channel 0
  {start: 14.634, freq: 195.998, gain: 0.630, dur: 0.888}, // note 55, channel 0
  {start: 15.122, freq: 123.471, gain: 0.630, dur: 0.423}, // note 47, channel 0
  {start: 15.610, freq: 523.251, gain: 0.921, dur: 1.829}, // note 72, channel 0
  {start: 15.614, freq: 174.614, gain: 0.630, dur: 1.814}, // note 53, channel 0
  {start: 15.619, freq: 293.665, gain: 0.630, dur: 0.723}, // note 62, channel 0
  {start: 15.622, freq: 220.000, gain: 0.339, dur: 1.817}, // note 57, channel 0
  {start: 16.447, freq: 329.628, gain: 0.630, dur: 0.992}, // note 64, channel 0
  {start: 17.561, freq: 880.000, gain: 0.921, dur: 0.854}, // note 81, channel 0
  {start: 17.565, freq: 164.814, gain: 0.630, dur: 1.836}, // note 52, channel 0
  {start: 17.580, freq: 220.000, gain: 0.339, dur: 1.810}, // note 57, channel 0
  {start: 17.588, freq: 293.665, gain: 0.630, dur: 0.704}, // note 62, channel 0
  {start: 18.394, freq: 261.626, gain: 0.630, dur: 0.996}, // note 60, channel 0
  {start: 18.575, freq: 783.991, gain: 0.921, dur: 0.377}, // note 79, channel 0
  {start: 19.515, freq: 261.626, gain: 0.630, dur: 0.729}, // note 60, channel 0
  {start: 19.515, freq: 164.814, gain: 0.630, dur: 0.740}, // note 52, channel 0
  {start: 19.522, freq: 220.000, gain: 0.339, dur: 1.819}, // note 57, channel 0
  {start: 19.551, freq: 659.255, gain: 0.921, dur: 0.813}, // note 76, channel 0
  {start: 20.339, freq: 146.832, gain: 0.630, dur: 0.976}, // note 50, channel 0
  {start: 20.348, freq: 293.665, gain: 0.630, dur: 0.994}, // note 62, channel 0
  {start: 21.443, freq: 130.813, gain: 0.630, dur: 0.733}, // note 48, channel 0
  {start: 21.443, freq: 220.000, gain: 0.339, dur: 0.737}, // note 57, channel 0
  {start: 21.447, freq: 329.628, gain: 0.630, dur: 0.748}, // note 64, channel 0
  {start: 21.463, freq: 493.883, gain: 0.921, dur: 0.787}, // note 71, channel 0
  {start: 22.303, freq: 293.665, gain: 0.630, dur: 1.112}, // note 62, channel 0
  {start: 22.310, freq: 195.998, gain: 0.630, dur: 1.017}, // note 55, channel 0
  {start: 22.317, freq: 123.471, gain: 0.630, dur: 1.033}, // note 47, channel 0
  {start: 22.985, freq: 391.995, gain: 0.921, dur: 0.430}, // note 67, channel 0
  {start: 23.419, freq: 174.614, gain: 0.630, dur: 1.813}, // note 53, channel 0
  {start: 23.424, freq: 293.665, gain: 0.630, dur: 1.820}, // note 62, channel 0
  {start: 23.427, freq: 220.000, gain: 0.339, dur: 1.817}, // note 57, channel 0
  {start: 23.500, freq: 349.228, gain: 0.921, dur: 0.741}, // note 65, channel 0
  {start: 24.878, freq: 659.255, gain: 0.921, dur: 0.450}, // note 76, channel 0
  {start: 25.356, freq: 523.251, gain: 0.921, dur: 0.797}, // note 72, channel 0
  {start: 25.370, freq: 164.814, gain: 0.630, dur: 1.836}, // note 52, channel 0
  {start: 25.385, freq: 220.000, gain: 0.339, dur: 1.810}, // note 57, channel 0
  {start: 25.393, freq: 329.628, gain: 0.630, dur: 0.826}, // note 64, channel 0
  {start: 26.199, freq: 261.626, gain: 0.630, dur: 0.996}, // note 60, channel 0
  {start: 27.320, freq: 164.814, gain: 0.630, dur: 1.338}, // note 52, channel 0
  {start: 27.320, freq: 261.626, gain: 0.630, dur: 1.826}, // note 60, channel 0
  {start: 27.325, freq: 698.456, gain: 0.921, dur: 0.742}, // note 77, channel 0
  {start: 27.327, freq: 220.000, gain: 0.339, dur: 1.819}, // note 57, channel 0
  {start: 28.293, freq: 659.255, gain: 0.921, dur: 0.979}, // note 76, channel 0
  {start: 28.780, freq: 146.832, gain: 0.630, dur: 0.339}, // note 50, channel 0
  {start: 29.248, freq: 220.000, gain: 0.339, dur: 0.874}, // note 57, channel 0
  {start: 29.248, freq: 130.813, gain: 0.630, dur: 1.484}, // note 48, channel 0
  {start: 29.252, freq: 293.665, gain: 0.630, dur: 1.846}, // note 62, channel 0
  {start: 29.267, freq: 587.330, gain: 0.921, dur: 0.722}, // note 74, channel 0
  {start: 30.084, freq: 587.330, gain: 0.921, dur: 0.376}, // note 74, channel 0
  {start: 30.244, freq: 195.998, gain: 0.630, dur: 0.888}, // note 55, channel 0
  {start: 30.732, freq: 123.471, gain: 0.630, dur: 0.423}, // note 47, channel 0
  {start: 31.220, freq: 523.251, gain: 0.921, dur: 1.829}, // note 72, channel 0
  {start: 33.171, freq: 880.000, gain: 0.921, dur: 0.854}, // note 81, channel 0
  {start: 34.185, freq: 783.991, gain: 0.921, dur: 0.377}, // note 79, channel 0
  {start: 35.161, freq: 659.255, gain: 0.921, dur: 0.813}, // note 76, channel 0
  {start: 37.073, freq: 493.883, gain: 0.921, dur: 0.787}, // note 71, channel 0
  {start: 38.595, freq: 391.995, gain: 0.921, dur: 0.430}, // note 67, channel 0
  {start: 39.110, freq: 349.228, gain: 0.921, dur: 0.741}, // note 65, channel 0
  {start: 40.488, freq: 659.255, gain: 0.921, dur: 0.450}, // note 76, channel 0
  {start: 40.965, freq: 523.251, gain: 0.921, dur: 0.797}, // note 72, channel 0
  {start: 42.935, freq: 698.456, gain: 0.921, dur: 0.742}, // note 77, channel 0
  {start: 43.902, freq: 659.255, gain: 0.921, dur: 0.979}, // note 76, channel 0
  {start: 44.877, freq: 587.330, gain: 0.921, dur: 0.722}, // note 74, channel 0
  {start: 45.694, freq: 587.330, gain: 0.921, dur: 0.376}, // note 74, channel 0
  {start: 46.829, freq: 523.251, gain: 0.921, dur: 1.463}, // note 72, channel 0
  {start: 46.833, freq: 174.614, gain: 0.630, dur: 0.228}, // note 53, channel 0
  {start: 46.838, freq: 293.665, gain: 0.630, dur: 0.235}, // note 62, channel 0
  {start: 46.841, freq: 220.000, gain: 0.339, dur: 0.232}, // note 57, channel 0
  {start: 47.663, freq: 174.614, gain: 0.630, dur: 0.138}, // note 53, channel 0
  {start: 47.667, freq: 329.628, gain: 0.630, dur: 0.138}, // note 64, channel 0
  {start: 47.671, freq: 220.000, gain: 0.339, dur: 0.130}, // note 57, channel 0
  {start: 48.618, freq: 587.330, gain: 0.921, dur: 0.122}, // note 74, channel 0
  {start: 48.780, freq: 880.000, gain: 0.921, dur: 0.854}, // note 81, channel 0
  {start: 48.785, freq: 164.814, gain: 0.630, dur: 0.269}, // note 52, channel 0
  {start: 48.800, freq: 220.000, gain: 0.339, dur: 0.243}, // note 57, channel 0
  {start: 48.808, freq: 293.665, gain: 0.630, dur: 0.258}, // note 62, channel 0
  {start: 49.614, freq: 164.814, gain: 0.630, dur: 0.119}, // note 52, channel 0
  {start: 49.614, freq: 261.626, gain: 0.630, dur: 0.127}, // note 60, channel 0
  {start: 49.625, freq: 220.000, gain: 0.339, dur: 0.104}, // note 57, channel 0
  {start: 49.795, freq: 783.991, gain: 0.921, dur: 0.377}, // note 79, channel 0
  {start: 50.310, freq: 698.456, gain: 0.921, dur: 0.300}, // note 77, channel 0
  {start: 50.735, freq: 261.626, gain: 0.630, dur: 0.265}, // note 60, channel 0
  {start: 50.735, freq: 164.814, gain: 0.630, dur: 0.276}, // note 52, channel 0
  {start: 50.742, freq: 220.000, gain: 0.339, dur: 0.251}, // note 57, channel 0
  {start: 50.770, freq: 659.255, gain: 0.921, dur: 0.814}, // note 76, channel 0
  {start: 51.559, freq: 146.832, gain: 0.630, dur: 0.116}, // note 50, channel 0
  {start: 51.567, freq: 220.000, gain: 0.339, dur: 0.123}, // note 57, channel 0
  {start: 51.567, freq: 293.665, gain: 0.630, dur: 0.134}, // note 62, channel 0
  {start: 52.195, freq: 523.251, gain: 0.921, dur: 0.379}, // note 72, channel 0
  {start: 52.663, freq: 130.813, gain: 0.630, dur: 0.250}, // note 48, channel 0
  {start: 52.663, freq: 220.000, gain: 0.339, dur: 0.254}, // note 57, channel 0
  {start: 52.667, freq: 329.628, gain: 0.630, dur: 0.265}, // note 64, channel 0
  {start: 52.683, freq: 493.883, gain: 0.921, dur: 0.787}, // note 71, channel 0
  {start: 53.522, freq: 293.665, gain: 0.630, dur: 0.198}, // note 62, channel 0
  {start: 53.529, freq: 195.998, gain: 0.630, dur: 0.104}, // note 55, channel 0
  {start: 53.537, freq: 123.471, gain: 0.630, dur: 0.119}, // note 47, channel 0
  {start: 53.566, freq: 391.995, gain: 0.921, dur: 0.377}, // note 67, channel 0
  {start: 54.204, freq: 391.995, gain: 0.921, dur: 0.176}, // note 67, channel 0
  {start: 54.638, freq: 174.614, gain: 0.630, dur: 0.228}, // note 53, channel 0
  {start: 54.643, freq: 293.665, gain: 0.630, dur: 0.235}, // note 62, channel 0
  {start: 54.646, freq: 220.000, gain: 0.339, dur: 0.232}, // note 57, channel 0
  {start: 54.720, freq: 349.228, gain: 0.921, dur: 0.741}, // note 65, channel 0
  {start: 55.467, freq: 174.614, gain: 0.630, dur: 0.138}, // note 53, channel 0
  {start: 55.472, freq: 391.995, gain: 0.630, dur: 0.138}, // note 67, channel 0
  {start: 55.476, freq: 220.000, gain: 0.339, dur: 0.130}, // note 57, channel 0
  {start: 55.488, freq: 659.255, gain: 0.921, dur: 1.060}, // note 76, channel 0
  {start: 56.575, freq: 523.251, gain: 0.921, dur: 0.797}, // note 72, channel 0
  {start: 56.589, freq: 164.814, gain: 0.630, dur: 0.269}, // note 52, channel 0
  {start: 56.605, freq: 220.000, gain: 0.339, dur: 0.243}, // note 57, channel 0
  {start: 56.613, freq: 329.628, gain: 0.630, dur: 0.258}, // note 64, channel 0
  {start: 57.419, freq: 164.814, gain: 0.630, dur: 0.119}, // note 52, channel 0
  {start: 57.419, freq: 261.626, gain: 0.630, dur: 0.127}, // note 60, channel 0
  {start: 57.430, freq: 220.000, gain: 0.339, dur: 0.104}, // note 57, channel 0
  {start: 58.540, freq: 261.626, gain: 0.630, dur: 0.265}, // note 60, channel 0
  {start: 58.540, freq: 164.814, gain: 0.630, dur: 0.276}, // note 52, channel 0
  {start: 58.545, freq: 698.456, gain: 0.921, dur: 0.742}, // note 77, channel 0
  {start: 58.547, freq: 220.000, gain: 0.339, dur: 0.251}, // note 57, channel 0
  {start: 59.364, freq: 146.832, gain: 0.630, dur: 0.116}, // note 50, channel 0
  {start: 59.372, freq: 220.000, gain: 0.339, dur: 0.123}, // note 57, channel 0
  {start: 59.372, freq: 349.228, gain: 0.630, dur: 0.134}, // note 65, channel 0
  {start: 59.390, freq: 659.255, gain: 0.921, dur: 1.101}, // note 76, channel 0
  {start: 60.467, freq: 130.813, gain: 0.630, dur: 0.250}, // note 48, channel 0
  {start: 60.467, freq: 220.000, gain: 0.339, dur: 0.254}, // note 57, channel 0
  {start: 60.472, freq: 329.628, gain: 0.630, dur: 0.265}, // note 64, channel 0
  {start: 60.487, freq: 587.330, gain: 0.921, dur: 0.722}, // note 74, channel 0
  {start: 61.304, freq: 587.330, gain: 0.921, dur: 0.376}, // note 74, channel 0
  {start: 61.327, freq: 293.665, gain: 0.630, dur: 0.198}, // note 62, channel 0
  {start: 61.334, freq: 195.998, gain: 0.630, dur: 0.104}, // note 55, channel 0
  {start: 61.341, freq: 123.471, gain: 0.630, dur: 0.119}, // note 47, channel 0
  {start: 62.443, freq: 174.614, gain: 0.630, dur: 1.814}, // note 53, channel 0
  {start: 62.448, freq: 293.665, gain: 0.630, dur: 0.723}, // note 62, channel 0
  {start: 62.451, freq: 220.000, gain: 0.339, dur: 1.817}, // note 57, channel 0
  {start: 63.276, freq: 329.628, gain: 0.630, dur: 0.992}, // note 64, channel 0
  {start: 64.394, freq: 164.814, gain: 0.630, dur: 1.836}, // note 52, channel 0
  {start: 64.410, freq: 220.000, gain: 0.339, dur: 1.810}, // note 57, channel 0
  {start: 64.418, freq: 293.665, gain: 0.630, dur: 0.704}, // note 62, channel 0
  {start: 65.224, freq: 261.626, gain: 0.630, dur: 0.996}, // note 60, channel 0
  {start: 66.345, freq: 261.626, gain: 0.630, dur: 0.729}, // note 60, channel 0
  {start: 66.345, freq: 164.814, gain: 0.630, dur: 0.740}, // note 52, channel 0
  {start: 66.352, freq: 220.000, gain: 0.339, dur: 1.819}, // note 57, channel 0
  {start: 67.169, freq: 146.832, gain: 0.630, dur: 0.976}, // note 50, channel 0
  {start: 67.177, freq: 293.665, gain: 0.630, dur: 0.994}, // note 62, channel 0
  {start: 68.272, freq: 130.813, gain: 0.630, dur: 0.733}, // note 48, channel 0
  {start: 68.272, freq: 220.000, gain: 0.339, dur: 0.737}, // note 57, channel 0
  {start: 68.276, freq: 329.628, gain: 0.630, dur: 0.748}, // note 64, channel 0
  {start: 69.132, freq: 293.665, gain: 0.630, dur: 1.112}, // note 62, channel 0
  {start: 69.139, freq: 195.998, gain: 0.630, dur: 1.017}, // note 55, channel 0
  {start: 69.146, freq: 123.471, gain: 0.630, dur: 1.033}, // note 47, channel 0
  {start: 70.248, freq: 174.614, gain: 0.630, dur: 1.813}, // note 53, channel 0
  {start: 70.253, freq: 293.665, gain: 0.630, dur: 1.820}, // note 62, channel 0
  {start: 70.256, freq: 220.000, gain: 0.339, dur: 1.817}, // note 57, channel 0
  {start: 72.199, freq: 164.814, gain: 0.630, dur: 1.836}, // note 52, channel 0
  {start: 72.214, freq: 220.000, gain: 0.339, dur: 1.810}, // note 57, channel 0
  {start: 72.223, freq: 329.628, gain: 0.630, dur: 0.826}, // note 64, channel 0
  {start: 73.028, freq: 261.626, gain: 0.630, dur: 0.996}, // note 60, channel 0
  {start: 74.149, freq: 164.814, gain: 0.630, dur: 1.338}, // note 52, channel 0
  {start: 74.149, freq: 261.626, gain: 0.630, dur: 1.826}, // note 60, channel 0
  {start: 74.157, freq: 220.000, gain: 0.339, dur: 1.819}, // note 57, channel 0
  {start: 75.610, freq: 146.832, gain: 0.630, dur: 0.339}, // note 50, channel 0
  {start: 76.077, freq: 220.000, gain: 0.339, dur: 0.874}, // note 57, channel 0
  {start: 76.077, freq: 130.813, gain: 0.630, dur: 1.484}, // note 48, channel 0
  {start: 76.081, freq: 293.665, gain: 0.630, dur: 1.846} // note 62, channel 0
];

// audio.js - Rich WebAudio MIDI synthesis for Educe game
let audioCtx;
let scheduledTimeouts = [];
let isPlaying = false;
let masterGainNode;
let bgmGainNode;
let sfxGainNode;
let masterVolume = 0.3; // Global volume control
let bgmVolume = 1.0;
let sfxVolume = 1.0;

function getAudioContext() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    // Create master gain node for global volume control
    masterGainNode = audioCtx.createGain();
    masterGainNode.gain.value = masterVolume;
    masterGainNode.connect(audioCtx.destination);

    // Create separate gain nodes for background music and sound effects
    bgmGainNode = audioCtx.createGain();
    bgmGainNode.gain.value = bgmVolume;
    bgmGainNode.connect(masterGainNode);

    sfxGainNode = audioCtx.createGain();
    sfxGainNode.gain.value = sfxVolume;
    sfxGainNode.connect(masterGainNode);
  }
  return audioCtx;
}

function playMidiSong(loop = true) {
  stopMidiSong();
  const ctx = getAudioContext();
  
  // Resume context if suspended (required for user gesture compliance)
  if (ctx.state === 'suspended') {
    ctx.resume();
  }
  
  isPlaying = true;
  console.log(`Starting MIDI playback with ${bgm_midi.length} notes`);

  let maxEnd = 0;
  
  // Schedule all notes
  for (const note of bgm_midi) {
    maxEnd = Math.max(maxEnd, note.start + note.dur);
    
    const timeout = setTimeout(() => {
      if (!isPlaying) return;
      playSnowflakeSynthNote(ctx, note.freq, note.dur, note.gain);
    }, note.start * 1000);
    
    scheduledTimeouts.push(timeout);
  }

  // Schedule loop if enabled
  if (loop) {
    const loopTimeout = setTimeout(() => {
      if (isPlaying) {
        console.log('Looping MIDI song...');
        playMidiSong(loop);
      }
    }, (maxEnd + 1.0) * 1000); // 1 second gap between loops
    
    scheduledTimeouts.push(loopTimeout);
  }
}

function stopMidiSong() {
  isPlaying = false;
  scheduledTimeouts.forEach(t => clearTimeout(t));
  scheduledTimeouts = [];
  console.log('MIDI playback stopped');
}

function setMasterVolume(volume) {
  masterVolume = Math.max(0, Math.min(1, volume));
  if (masterGainNode) {
    masterGainNode.gain.setValueAtTime(masterVolume, audioCtx.currentTime);
  }
}

function getMasterVolume() {
  return masterVolume;
}

function setBgmVolume(volume) {
  bgmVolume = Math.max(0, Math.min(1, volume));
  if (bgmGainNode) {
    bgmGainNode.gain.setValueAtTime(bgmVolume, audioCtx.currentTime);
  }
}

function getBgmVolume() {
  return bgmVolume;
}

function setSfxVolume(volume) {
  sfxVolume = Math.max(0, Math.min(1, volume));
  if (sfxGainNode) {
    sfxGainNode.gain.setValueAtTime(sfxVolume, audioCtx.currentTime);
  }
}

function getSfxVolume() {
  return sfxVolume;
}

// Play a short footstep sound effect
function playFootstep() {
  const ctx = getAudioContext();
  const now = ctx.currentTime;

  // Slight randomization for natural variation
  const osc = ctx.createOscillator();
  osc.type = 'sine';
  osc.frequency.value = 80 + Math.random() * 40;

  const gain = ctx.createGain();
  gain.gain.setValueAtTime(0, now);
  gain.gain.linearRampToValueAtTime(0.5, now + 0.01);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);

  osc.connect(gain);
  gain.connect(sfxGainNode);

  osc.start(now);
  osc.stop(now + 0.25);
}

function playDinoRoar() {
  const ctx = getAudioContext();
  const now = ctx.currentTime;

  // --- Loud, punchy, oink-like dino grunt ---

  // Main grunt body (sawtooth for bite)
  const osc1 = ctx.createOscillator();
  osc1.type = 'sawtooth';
  osc1.frequency.setValueAtTime(110, now);
  osc1.frequency.linearRampToValueAtTime(80, now + 0.13);
  osc1.frequency.linearRampToValueAtTime(60, now + 0.22);

  // Mid/high overtone (square for nasal/oink character)
  const osc2 = ctx.createOscillator();
  osc2.type = 'square';
  osc2.frequency.setValueAtTime(220, now);
  osc2.frequency.linearRampToValueAtTime(180, now + 0.09);
  osc2.frequency.linearRampToValueAtTime(120, now + 0.18);

  // Short noise burst for percussive attack
  const noise = ctx.createBufferSource();
  const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.18, ctx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < data.length; i++) {
    data[i] = (Math.random() * 2 - 1) * (1 - i / data.length) * 0.5;
  }
  noise.buffer = buffer;

  // Gain envelopes
  // Main grunt: fast attack, short decay
  const gain1 = ctx.createGain();
  gain1.gain.setValueAtTime(0, now);
  gain1.gain.linearRampToValueAtTime(0.18, now + 0.01);
  gain1.gain.linearRampToValueAtTime(0.13, now + 0.09);
  gain1.gain.linearRampToValueAtTime(0.01, now + 0.22);
  gain1.gain.linearRampToValueAtTime(0, now + 0.28);

  // Overtone: quick, nasal, fades fast
  const gain2 = ctx.createGain();
  gain2.gain.setValueAtTime(0, now);
  gain2.gain.linearRampToValueAtTime(0.13, now + 0.02);
  gain2.gain.linearRampToValueAtTime(0.09, now + 0.11);
  gain2.gain.linearRampToValueAtTime(0, now + 0.19);

  // Noise: percussive, very short
  const noiseGain = ctx.createGain();
  noiseGain.gain.setValueAtTime(0, now);
  noiseGain.gain.linearRampToValueAtTime(0.12, now + 0.01);
  noiseGain.gain.linearRampToValueAtTime(0, now + 0.09);

  // Connect layers
  osc1.connect(gain1);
  osc2.connect(gain2);
  noise.connect(noiseGain);

  gain1.connect(sfxGainNode);
  gain2.connect(sfxGainNode);
  noiseGain.connect(sfxGainNode);

  // Start and stop
  osc1.start(now);
  osc2.start(now);
  noise.start(now);

  osc1.stop(now + 0.28);
  osc2.stop(now + 0.19);
  noise.stop(now + 0.09);
}

// Dino spots the player - alert growl
function playDinoSpotted() {
  const ctx = getAudioContext();
  const now = ctx.currentTime;

  // Sharp, alerting growl when dino spots player
  const osc1 = ctx.createOscillator();
  osc1.type = 'sawtooth';
  osc1.frequency.setValueAtTime(180, now);
  osc1.frequency.exponentialRampToValueAtTime(220, now + 0.1);
  osc1.frequency.exponentialRampToValueAtTime(160, now + 0.3);

  const osc2 = ctx.createOscillator();
  osc2.type = 'square';
  osc2.frequency.setValueAtTime(90, now);
  osc2.frequency.exponentialRampToValueAtTime(110, now + 0.15);

  const gain1 = ctx.createGain();
  gain1.gain.setValueAtTime(0, now);
  gain1.gain.linearRampToValueAtTime(0.3, now + 0.05);
  gain1.gain.exponentialRampToValueAtTime(0.001, now + 0.4);

  const gain2 = ctx.createGain();
  gain2.gain.setValueAtTime(0, now);
  gain2.gain.linearRampToValueAtTime(0.2, now + 0.03);
  gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.35);

  osc1.connect(gain1);
  osc2.connect(gain2);
  gain1.connect(sfxGainNode);
  gain2.connect(sfxGainNode);

  osc1.start(now);
  osc2.start(now);
  osc1.stop(now + 0.4);
  osc2.stop(now + 0.35);
}

// Dino preparing to charge - menacing windup sound
function playDinoChargeWindup() {
  // const ctx = getAudioContext();
  // const now = ctx.currentTime;

  // // Deep menacing growl that builds in intensity
  // const osc1 = ctx.createOscillator();
  // osc1.type = 'sawtooth';
  // osc1.frequency.setValueAtTime(45, now);
  // osc1.frequency.exponentialRampToValueAtTime(85, now + 0.4);
  // osc1.frequency.exponentialRampToValueAtTime(120, now + 0.8);

  // // Mid-range snarl
  // const osc2 = ctx.createOscillator();
  // osc2.type = 'square';
  // osc2.frequency.setValueAtTime(90, now);
  // osc2.frequency.exponentialRampToValueAtTime(140, now + 0.5);
  // osc2.frequency.exponentialRampToValueAtTime(180, now + 0.8);

  // // Higher growl harmonics
  // const osc3 = ctx.createOscillator();
  // osc3.type = 'sawtooth';
  // osc3.frequency.setValueAtTime(180, now + 0.2);
  // osc3.frequency.exponentialRampToValueAtTime(280, now + 0.6);
  // osc3.frequency.exponentialRampToValueAtTime(320, now + 0.8);

  // // Gain envelopes - building intensity
  // const gain1 = ctx.createGain();
  // gain1.gain.setValueAtTime(0, now);
  // gain1.gain.linearRampToValueAtTime(0.4, now + 0.1);
  // gain1.gain.setValueAtTime(0.4, now + 0.7);
  // gain1.gain.exponentialRampToValueAtTime(0.001, now + 1.0);

  // const gain2 = ctx.createGain();
  // gain2.gain.setValueAtTime(0, now);
  // gain2.gain.linearRampToValueAtTime(0.3, now + 0.2);
  // gain2.gain.linearRampToValueAtTime(0.5, now + 0.8);
  // gain2.gain.exponentialRampToValueAtTime(0.001, now + 1.0);

  // const gain3 = ctx.createGain();
  // gain3.gain.setValueAtTime(0, now + 0.2);
  // gain3.gain.linearRampToValueAtTime(0.2, now + 0.4);
  // gain3.gain.linearRampToValueAtTime(0.4, now + 0.8);
  // gain3.gain.exponentialRampToValueAtTime(0.001, now + 1.0);

  // // Connect oscillators
  // osc1.connect(gain1);
  // osc2.connect(gain2);
  // osc3.connect(gain3);
  
  // gain1.connect(sfxGainNode);
  // gain2.connect(sfxGainNode);
  // gain3.connect(sfxGainNode);

  // // Start and stop oscillators
  // osc1.start(now);
  // osc2.start(now);
  // osc3.start(now + 0.2);
  
  // osc1.stop(now + 1.0);
  // osc2.stop(now + 1.0);
  // osc3.stop(now + 1.0);
}

// Dino charging attack - fast whoosh with impact
function playDinoCharge() {
  const ctx = getAudioContext();
  const now = ctx.currentTime;

  // Fast whoosh sound
  const noise = ctx.createBufferSource();
  const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.5, ctx.sampleRate);
  const data = buffer.getChannelData(0);
  
  // Generate white noise and filter it
  for (let i = 0; i < data.length; i++) {
    data[i] = (Math.random() * 2 - 1) * 0.5;
  }
  noise.buffer = buffer;

  const filter = ctx.createBiquadFilter();
  filter.type = 'bandpass';
  filter.frequency.setValueAtTime(2000, now);
  filter.frequency.exponentialRampToValueAtTime(800, now + 0.3);
  filter.Q.value = 10;

  const gain = ctx.createGain();
  gain.gain.setValueAtTime(0, now);
  gain.gain.linearRampToValueAtTime(0.6, now + 0.02);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);

  noise.connect(filter);
  filter.connect(gain);
  gain.connect(sfxGainNode);

  noise.start(now);
  noise.stop(now + 0.4);
}

// Dino attack impact - aggressive hit sound
function playDinoAttack() {
  const ctx = getAudioContext();
  const now = ctx.currentTime;

  // Sharp attack sound with multiple components
  const osc1 = ctx.createOscillator();
  osc1.type = 'sawtooth';
  osc1.frequency.setValueAtTime(200, now);
  osc1.frequency.exponentialRampToValueAtTime(80, now + 0.2);

  const osc2 = ctx.createOscillator();
  osc2.type = 'square';
  osc2.frequency.setValueAtTime(400, now);
  osc2.frequency.exponentialRampToValueAtTime(150, now + 0.15);

  // Add noise burst for impact
  const noise = ctx.createBufferSource();
  const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.1, ctx.sampleRate);
  const data = buffer.getChannelData(0);
  
  for (let i = 0; i < data.length; i++) {
    data[i] = (Math.random() * 2 - 1) * 0.8;
  }
  noise.buffer = buffer;

  const gain1 = ctx.createGain();
  gain1.gain.setValueAtTime(0, now);
  gain1.gain.linearRampToValueAtTime(0.5, now + 0.01);
  gain1.gain.exponentialRampToValueAtTime(0.001, now + 0.3);

  const gain2 = ctx.createGain();
  gain2.gain.setValueAtTime(0, now);
  gain2.gain.linearRampToValueAtTime(0.4, now + 0.005);
  gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.2);

  const noiseGain = ctx.createGain();
  noiseGain.gain.setValueAtTime(0, now);
  noiseGain.gain.linearRampToValueAtTime(0.3, now + 0.005);
  noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

  osc1.connect(gain1);
  osc2.connect(gain2);
  noise.connect(noiseGain);
  
  gain1.connect(sfxGainNode);
  gain2.connect(sfxGainNode);
  noiseGain.connect(sfxGainNode);

  osc1.start(now);
  osc2.start(now);
  noise.start(now);
  
  osc1.stop(now + 0.3);
  osc2.stop(now + 0.2);
  noise.stop(now + 0.1);
}

// Dino stunned - dizzy, confused sound
function playDinoStunned() {
  const ctx = getAudioContext();
  const now = ctx.currentTime;

  // Wobbly, descending sound to indicate confusion
  const osc1 = ctx.createOscillator();
  osc1.type = 'sine';
  osc1.frequency.setValueAtTime(300, now);
  osc1.frequency.exponentialRampToValueAtTime(150, now + 0.8);

  // Add warble effect
  const warble = ctx.createOscillator();
  warble.type = 'sine';
  warble.frequency.value = 3; // Slow warble

  const warbleGain = ctx.createGain();
  warbleGain.gain.value = 20; // Frequency modulation depth

  const gain = ctx.createGain();
  gain.gain.setValueAtTime(0, now);
  gain.gain.linearRampToValueAtTime(0.3, now + 0.1);
  gain.gain.setValueAtTime(0.3, now + 0.6);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 1.0);

  warble.connect(warbleGain);
  warbleGain.connect(osc1.frequency);

  osc1.connect(gain);
  gain.connect(sfxGainNode);

  warble.start(now);
  osc1.start(now);
  
  warble.stop(now + 1.0);
  osc1.stop(now + 1.0);
}

// Dino searching - curious sniffing sounds
function playDinoSearching() {
  const ctx = getAudioContext();
  const now = ctx.currentTime;

  // Short sniffing sounds - play 3 quick sniffs
  for (let i = 0; i < 3; i++) {
    const delay = i * 0.3;
    
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(120 + Math.random() * 40, now + delay);
    osc.frequency.exponentialRampToValueAtTime(80 + Math.random() * 20, now + delay + 0.1);

    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0, now + delay);
    gain.gain.linearRampToValueAtTime(0.2, now + delay + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.15);

    osc.connect(gain);
    gain.connect(sfxGainNode);

    osc.start(now + delay);
    osc.stop(now + delay + 0.15);
  }
}

// Dino wandering - occasional grunt or grumble
function playDinoWandering() {
  const ctx = getAudioContext();
  const now = ctx.currentTime;

  // Low, quiet grumble
  const osc = ctx.createOscillator();
  osc.type = 'sawtooth';
  osc.frequency.setValueAtTime(60 + Math.random() * 20, now);
  osc.frequency.exponentialRampToValueAtTime(40 + Math.random() * 15, now + 0.4);

  const gain = ctx.createGain();
  gain.gain.setValueAtTime(0, now);
  gain.gain.linearRampToValueAtTime(0.15, now + 0.05);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);

  osc.connect(gain);
  gain.connect(sfxGainNode);

  osc.start(now);
  osc.stop(now + 0.5);
}

function playSnowflakeSynthNote(ctx, freq, dur, gain) {
  const now = ctx.currentTime;
  
  // --- Multi-layer synth (Snowflake-inspired for rich sound) ---
  
  // Main oscillator - sawtooth for brightness
  const osc1 = ctx.createOscillator();
  osc1.type = 'sawtooth';
  osc1.frequency.value = freq;
  
  // Sub oscillator - sine wave one octave down for warmth
  const osc2 = ctx.createOscillator();
  osc2.type = 'sine';
  osc2.frequency.value = freq * 0.5;
  
  // Detune oscillator - slightly detuned sawtooth for chorus effect
  const osc3 = ctx.createOscillator();
  osc3.type = 'sawtooth';
  osc3.frequency.value = freq * 1.012; // +12 cents
  
  // Triangle oscillator - slightly detuned down for richness
  const osc4 = ctx.createOscillator();
  osc4.type = 'triangle';
  osc4.frequency.value = freq * 0.997; // -3 cents
  
  // Individual gain nodes for mixing
  const g1 = ctx.createGain(); g1.gain.value = 0.35; // Main
  const g2 = ctx.createGain(); g2.gain.value = 0.25; // Sub
  const g3 = ctx.createGain(); g3.gain.value = 0.20; // Detune
  const g4 = ctx.createGain(); g4.gain.value = 0.15; // Triangle
  
  // Connect oscillators to their gain nodes
  osc1.connect(g1);
  osc2.connect(g2);
  osc3.connect(g3);
  osc4.connect(g4);
  
  // Premix all oscillators
  const premix = ctx.createGain();
  g1.connect(premix);
  g2.connect(premix);
  g3.connect(premix);
  g4.connect(premix);
  
  // Low-pass filter for warmth and anti-aliasing
  const filter = ctx.createBiquadFilter();
  filter.type = 'lowpass';
  filter.frequency.value = Math.min(freq * 4, 8000); // Filter frequency based on note
  filter.Q.value = 8; // Resonance for character
  
  // Filter frequency modulation for movement
  filter.frequency.setValueAtTime(freq * 4, now);
  filter.frequency.exponentialRampToValueAtTime(freq * 2, now + dur * 0.3);
  filter.frequency.exponentialRampToValueAtTime(freq * 1.5, now + dur);
  
  premix.connect(filter);
  
  // ADSR Envelope
  const env = ctx.createGain();
  const attack = Math.min(dur * 0.08, 0.12);   // Quick attack
  const decay = Math.min(dur * 0.15, 0.25);    // Short decay
  const sustain = 0.7;                          // Sustain level
  const release = Math.min(dur * 0.4, 0.6);    // Medium release
  
  const peakGain = gain * 0.4; // Scale down to prevent clipping
  const sustainGain = peakGain * sustain;
  
  // Envelope automation
  env.gain.setValueAtTime(0, now);
  env.gain.linearRampToValueAtTime(peakGain, now + attack);
  env.gain.linearRampToValueAtTime(sustainGain, now + attack + decay);
  env.gain.setValueAtTime(sustainGain, now + dur - release);
  env.gain.linearRampToValueAtTime(0, now + dur);
  
  // Connect filter through envelope to master gain
  filter.connect(env);
  env.connect(bgmGainNode);
  
  // Add subtle vibrato for expressiveness on longer notes
  if (dur > 0.5) {
    const vibrato = ctx.createOscillator();
    const vibratoGain = ctx.createGain();
    
    vibrato.type = 'sine';
    vibrato.frequency.value = 5; // 5 Hz vibrato
    vibratoGain.gain.value = freq * 0.01; // 1% depth
    
    vibrato.connect(vibratoGain);
    vibratoGain.connect(osc1.frequency);
    vibratoGain.connect(osc3.frequency);
    
    vibrato.start(now + attack + decay);
    vibrato.stop(now + dur);
  }
  
  // Start and stop all oscillators
  const oscillators = [osc1, osc2, osc3, osc4];
  oscillators.forEach(osc => {
    osc.start(now);
    osc.stop(now + dur + 0.1); // Small extra time for envelope tail
  });
}

// Utility function to unlock audio context on user gesture
function unlockAudioContext() {
  const ctx = getAudioContext();
  if (ctx.state === 'suspended') {
    ctx.resume().then(() => {
      console.log('Audio context unlocked');
    });
  }
}

const MAX_NPCS_PER_ROOM = 16;

const WORLD_FILE_URL = new URL('./world.json', import.meta.url);

class MapManager {
  constructor(worldData) {
    this.world = worldData;
    this.currentRoomX = worldData.startRoomX || 0;
    this.currentRoomY = worldData.startRoomY || 0;
    this.ensureNpcGrid();
  }

  ensureNpcGrid() {
    const rooms = this.world.rooms || [];
    const maxY = this.world.worldHeight ?? rooms.length;
    const maxX = this.world.worldWidth ?? (rooms[0]?.length ?? 0);

    if (!Array.isArray(this.world.npcs)) {
      this.world.npcs = Array.from({ length: maxY }, () => Array.from({ length: maxX }, () => []));
      return;
    }

    if (this.world.npcs.length < maxY) {
      for (let y = this.world.npcs.length; y < maxY; y++) {
        this.world.npcs[y] = Array.from({ length: maxX }, () => []);
      }
    }

    for (let y = 0; y < maxY; y++) {
      if (!Array.isArray(this.world.npcs[y])) {
        this.world.npcs[y] = Array.from({ length: maxX }, () => []);
      }

      if (this.world.npcs[y].length < maxX) {
        for (let x = this.world.npcs[y].length; x < maxX; x++) {
          this.world.npcs[y][x] = [];
        }
      }

      for (let x = 0; x < maxX; x++) {
        if (!Array.isArray(this.world.npcs[y][x])) {
          this.world.npcs[y][x] = [];
        }
      }
    }
  }

  ensureNpcList(roomX, roomY) {
    this.ensureNpcGrid();
    const grid = this.world.npcs;
    const safeRow = Math.max(0, Math.min(roomY, grid.length - 1));
    const row = grid[safeRow] ?? [];
    const safeCol = Math.max(0, Math.min(roomX, row.length - 1));
    if (!Array.isArray(row[safeCol])) {
      row[safeCol] = [];
    }
    return row[safeCol];
  }

  getRoom(roomX, roomY) {
    const worldRows = this.world.rooms || [];
    const maxY = this.world.worldHeight ?? worldRows.length;
    const maxX = this.world.worldWidth ?? (worldRows[0]?.length ?? 0);

    if (roomY < 0 || roomY >= maxY || roomX < 0 || roomX >= maxX) {
      return null;
    }

    const row = worldRows[roomY];
    if (!row) return null;
    return row[roomX] || null;
  }

  getCurrentMap() {
    const width = Math.min(this.world.roomWidth, ROOM_TILE_COLS);
    const height = Math.min(this.world.roomHeight, ROOM_TILE_ROWS);
    return {
      width,
      height,
      tileData: this.world.rooms[this.currentRoomY][this.currentRoomX]
    };
  }

  getCurrentNpcs() {
    return [...this.ensureNpcList(this.currentRoomX, this.currentRoomY)];
  }

  getNpcCount(roomX = this.currentRoomX, roomY = this.currentRoomY) {
    const list = this.ensureNpcList(roomX, roomY);
    return list.length;
  }

  removeNpcByIndex(roomX, roomY, index) {
    const list = this.ensureNpcList(roomX, roomY);
    if (index < 0 || index >= list.length) {
      return false;
    }
    list.splice(index, 1);
    return true;
  }

  toggleNpc(roomX, roomY, row, col) {
    if (row < 0 || col < 0 || row >= ROOM_TILE_ROWS || col >= ROOM_TILE_COLS) {
      return 'ignored';
    }

    const list = this.ensureNpcList(roomX, roomY);
    const index = list.findIndex((npc) => npc.row === row && npc.col === col);
    if (index === -1) {
      if (list.length >= MAX_NPCS_PER_ROOM) {
        return 'limit';
      }
      list.push({ row, col });
      return 'added';
    }

    list.splice(index, 1);
    return 'removed';
  }

  toggleNpcInCurrentRoom(row, col) {
    return this.toggleNpc(this.currentRoomX, this.currentRoomY, row, col);
  }

  setTile(row, col, tileId) {
    this.ensureNpcGrid();
    const map = this.world.rooms[this.currentRoomY][this.currentRoomX];
    if (
      row >= 0 && row < map.length && row < ROOM_TILE_ROWS &&
      col >= 0 && col < map[0].length && col < ROOM_TILE_COLS
    ) {
      map[row][col] = tileId;
      return true;
    }
    return false;
  }

  
  // Dev tooling removed in production

}

/*
  EDUCE WEB PLATFORM - JAVASCRIPT LAYER WITH WEBGPU + TILE EDITOR
*/
const RUNTIME_CONFIG = globalThis.RUNTIME_CONFIG || {};
const DEV_TOOLS_ENABLED = RUNTIME_CONFIG.devTools !== undefined ? !!RUNTIME_CONFIG.devTools : true;

// Game dimensions
const GAME_WIDTH = CONFIG_WIDTH;
const GAME_HEIGHT = CONFIG_HEIGHT;
const TILE_WIDTH = CONFIG_TILE_PIXEL_WIDTH;
const TILE_HEIGHT = CONFIG_TILE_PIXEL_HEIGHT;
const ROOM_TILE_COLS = CONFIG_ROOM_TILE_COLS;
const ROOM_TILE_ROWS = CONFIG_ROOM_TILE_ROWS;

const horizontalAligned = (GAME_WIDTH % TILE_WIDTH) === 0;
const verticalRemainder = GAME_HEIGHT % TILE_HEIGHT;
if (!horizontalAligned || verticalRemainder !== 0) {
  console.warn(`Game resolution leaves ${verticalRemainder}px extra vertically; rendering will anchor tiles to the top and leave the remainder at the bottom.`);
}

const SHADER_URL = new URL('./shader.wgsl', import.meta.url);
const ATLAS_IMAGE_URL = new URL('./assets.png', import.meta.url);
const ATLAS_DATA_URL = new URL('./atlas.json', import.meta.url);
const WORLD_DATA_URL = new URL('./world.json', import.meta.url);
const WASM_URL = new URL('./main.wasm', import.meta.url);
const MAX_NPCS_PER_ROOM = 16;
const MAX_CHARACTERS = MAX_NPCS_PER_ROOM + 1;
const NPC_MEMORY_OFFSET = 600 * 1024;
const CHARACTER_ANIMATION = 'player_walk_left';
const characterUniformData = new Float32Array(12);
let characterFrameWidth = 32;
let characterFrameHeight = 32;

// Setup canvas
const canvas = document.getElementById('screen');

// WASM instance and exports
let wasm = null;
let memory = null;

// WebGPU state
let device = null;
let gpuContext = null;
let pipeline = null;
let tilePipeline = null;
let tileBindGroup = null;
let characterUniformBuffers = [];
let characterBindGroups = [];
let tileGlobalsBuffer = null;
let tileInstanceBuffer = null;
let atlasWidth = 0;
let atlasHeight = 0;
let spriteSampler = null;
let spriteTextureView = null;

// Sprite/Atlas system
let atlasData = null;
let atlasLoaded = false;

// Map/Editor system
let mapManager = null;
let levelEditor = null;
let devToolsInitialized = false;
let currentRoomX = 0;
let currentRoomY = 0;
let tileInstanceCount = 0;
let initialNpcSyncPending = true;
let lastNpcCount = 0;
let lastRoomSent = `${currentRoomX},${currentRoomY}`;

// Input state
const inputState = {
  moveUp: false,
  moveDown: false,
  moveLeft: false,
  moveRight: false,
  actionUp: false,
  actionDown: false,
  actionLeft: false,
  actionRight: false,
  leftShoulder: false,
  rightShoulder: false,
  start: false,
  back: false,
  stickX: 0.0,
  stickY: 0.0,
  isAnalog: false
};

// Gamepad state
let gamepadIndex = -1;

// Timing
let lastTime = performance.now();

//
// Canvas sizing
//

function resizeCanvas() {
  const scaleX = Math.floor(window.innerWidth / GAME_WIDTH);
  const scaleY = Math.floor(window.innerHeight / GAME_HEIGHT);
  const scale = Math.max(1, Math.min(scaleX, scaleY));
  
  canvas.width = GAME_WIDTH;
  canvas.height = GAME_HEIGHT;
  
  canvas.style.width = `${GAME_WIDTH * scale}px`;
  canvas.style.height = `${GAME_HEIGHT * scale}px`;
  
  console.log(`Canvas: ${GAME_WIDTH}x${GAME_HEIGHT}, Display scale: ${scale}x`);
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();

//
// Input handling
//

const keyMap = {
  'KeyW': 'moveUp', 'ArrowUp': 'moveUp',
  'KeyS': 'moveDown', 'ArrowDown': 'moveDown',
  'KeyA': 'moveLeft', 'ArrowLeft': 'moveLeft',
  'KeyD': 'moveRight', 'ArrowRight': 'moveRight',
  'Space': 'actionDown',  // Jump with Space
  'KeyI': 'actionUp',
  'KeyK': 'actionDown',
  'KeyJ': 'actionLeft',
  'KeyL': 'actionRight',
  'KeyQ': 'leftShoulder', 'ShiftLeft': 'leftShoulder',
  'KeyE': 'rightShoulder',
  'Enter': 'start',
  'Escape': 'back'
};

document.addEventListener('keydown', (e) => {
  // Handle Ctrl+S for saving in editor mode
  if(e.ctrlKey && e.key === 's') {
    if(DEV_TOOLS_ENABLED && levelEditor && levelEditor.isEditorMode) {
      e.preventDefault();
      console.log('Ctrl+S pressed - saving map...');
      levelEditor.saveCurrentMap();
    }
    return;
  }
  
  // Toggle editor mode with 'E' key
  if(e.code === 'KeyE' && DEV_TOOLS_ENABLED) {
    if(levelEditor) {
      levelEditor.toggleEditorMode();
      updateEditorStatus();
      e.preventDefault();
    }
    return;
  }
  
  // Don't send game input while in editor mode
  if(levelEditor && levelEditor.isEditorMode) {
    return;
  }
  
  const action = keyMap[e.code];
  if(action && gamepadIndex === -1) {
    inputState[action] = true;
    inputState.isAnalog = false;
    e.preventDefault();
  }
});

document.addEventListener('keyup', (e) => {
  // Don't send game input while in editor mode
  if(levelEditor && levelEditor.isEditorMode) {
    return;
  }
  
  const action = keyMap[e.code];
  if(action && gamepadIndex === -1) {
    inputState[action] = false;
    e.preventDefault();
  }
});

// Gamepad handling
function updateGamepadInput() {
  const gamepads = navigator.getGamepads();
  
  if(gamepadIndex === -1) {
    for(let i = 0; i < gamepads.length; i++) {
      if(gamepads[i]) {
        gamepadIndex = i;
        console.log(`Gamepad connected: ${gamepads[i].id}`);
        break;
      }
    }
  }
  
  if(gamepadIndex !== -1 && gamepads[gamepadIndex]) {
    const gamepad = gamepads[gamepadIndex];
    
    const leftStickX = gamepad.axes[0] || 0;
    const leftStickY = gamepad.axes[1] || 0;
    
    const deadzone = 0.15;
    inputState.stickX = Math.abs(leftStickX) > deadzone ? leftStickX : 0.0;
    inputState.stickY = Math.abs(leftStickY) > deadzone ? leftStickY : 0.0;
    inputState.isAnalog = (inputState.stickX !== 0.0 || inputState.stickY !== 0.0);
    
    inputState.moveUp = gamepad.buttons[12]?.pressed || false;
    inputState.moveDown = gamepad.buttons[13]?.pressed || false;
    inputState.moveLeft = gamepad.buttons[14]?.pressed || false;
    inputState.moveRight = gamepad.buttons[15]?.pressed || false;
    
    inputState.actionDown = gamepad.buttons[0]?.pressed || false;
    inputState.actionRight = gamepad.buttons[1]?.pressed || false;
    inputState.actionLeft = gamepad.buttons[2]?.pressed || false;
    inputState.actionUp = gamepad.buttons[3]?.pressed || false;
    
    inputState.leftShoulder = gamepad.buttons[4]?.pressed || false;
    inputState.rightShoulder = gamepad.buttons[5]?.pressed || false;
    
    inputState.start = gamepad.buttons[9]?.pressed || false;
    inputState.back = gamepad.buttons[8]?.pressed || false;
  }
}

window.addEventListener('gamepadconnected', (e) => {
  console.log(`Gamepad connected: ${e.gamepad.id}`);
  gamepadIndex = e.gamepad.index;
});

window.addEventListener('gamepaddisconnected', (e) => {
  console.log(`Gamepad disconnected: ${e.gamepad.id}`);
  if(e.gamepad.index === gamepadIndex) {
    gamepadIndex = -1;
  }
});

//
// Main game loop
//

function gameLoop(currentTime) {
  requestAnimationFrame(gameLoop);
  
  const dt = Math.min((currentTime - lastTime) / 1000.0, 0.1);
  lastTime = currentTime;
  
  updateGamepadInput();
  
  // Don't update game if in editor mode
  if (!levelEditor || !levelEditor.isEditorMode) {
    // Send input to WASM
    wasm.SetControllerInput(
      0,
      inputState.isAnalog,
      inputState.stickX,
      inputState.stickY,
      inputState.moveUp,
      inputState.moveDown,
      inputState.moveLeft,
      inputState.moveRight,
      inputState.actionUp,
      inputState.actionDown,
      inputState.actionLeft,
      inputState.actionRight,
      inputState.leftShoulder,
      inputState.rightShoulder,
      inputState.start,
      inputState.back
    );
    
    // Update game logic (C++ updates game state)
    wasm.WebUpdateAndRender(dt);
    
    // Check if player changed rooms
    checkRoomChange();
  }
  
  // Render with WebGPU
  if (device) {
    renderScene();
  }
}

//
// WebGPU Rendering
//

async function initWebGPU() {
  try {
    // Request WebGPU adapter and device
    const adapter = await navigator.gpu?.requestAdapter();
    device = await adapter?.requestDevice();
    if (!device) {
      console.error('WebGPU not supported');
      return false;
    }

    // Configure canvas context for WebGPU
    gpuContext = canvas.getContext('webgpu');
    const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
    gpuContext.configure({
      device,
      format: presentationFormat,
    });

  // Load shader code
  const shaderCode = await fetch(SHADER_URL).then(res => res.text());
    
    const module = device.createShaderModule({
      label: 'sprite shader',
      code: shaderCode,
    });

    // Create sprite rendering pipeline
    pipeline = device.createRenderPipeline({
      label: 'sprite pipeline',
      layout: 'auto',
      vertex: { entryPoint: 'vs', module },
      fragment: {
        entryPoint: 'fs',
        module,
        targets: [{
          format: presentationFormat,
          blend: {
            color: {
              srcFactor: 'src-alpha',
              dstFactor: 'one-minus-src-alpha',
              operation: 'add',
            },
            alpha: {
              srcFactor: 'one',
              dstFactor: 'one-minus-src-alpha',
              operation: 'add',
            },
          },
        }],
      },
    });

  // Load sprite atlas
  const imgBitmap = await createImageBitmap(await fetch(ATLAS_IMAGE_URL).then(r => r.blob()));
  atlasData = await fetch(ATLAS_DATA_URL).then(r => r.json());
  const characterFrames = atlasData?.[CHARACTER_ANIMATION];
  if (Array.isArray(characterFrames) && characterFrames.length > 0) {
    characterFrameWidth = characterFrames[0].width ?? characterFrameWidth;
    characterFrameHeight = characterFrames[0].height ?? characterFrameHeight;
  }
    
    atlasWidth = imgBitmap.width;
    atlasHeight = imgBitmap.height;
    console.log('Atlas loaded:', atlasWidth, 'x', atlasHeight);

    // Create texture from atlas
    const texture = device.createTexture({
      size: [imgBitmap.width, imgBitmap.height],
      format: 'rgba8unorm',
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
    });

    device.queue.copyExternalImageToTexture(
      { source: imgBitmap },
      { texture: texture },
      [imgBitmap.width, imgBitmap.height]
    );

    // Create sampler
    spriteSampler = device.createSampler({
      magFilter: 'nearest',
      minFilter: 'nearest',
    });

    spriteTextureView = texture.createView();

    const uniformBufferSize = 12 * 4;
    characterUniformBuffers = Array.from({ length: MAX_CHARACTERS }, () =>
      device.createBuffer({
        size: uniformBufferSize,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      })
    );

    characterBindGroups = characterUniformBuffers.map((buffer) =>
      device.createBindGroup({
        layout: pipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: spriteSampler },
          { binding: 1, resource: spriteTextureView },
          { binding: 2, resource: { buffer } },
        ],
      })
    );

    // Create tile rendering pipeline
    tilePipeline = device.createRenderPipeline({
      label: 'tile pipeline',
      layout: 'auto',
      vertex: {
        entryPoint: 'tile_vs',
        module,
        buffers: [
          {
            arrayStride: 24, // 6 floats: tilePos(2) + frameRect(4)
            stepMode: 'instance',
            attributes: [
              { shaderLocation: 0, offset: 0, format: 'float32x2' }, // tile position
              { shaderLocation: 1, offset: 8, format: 'float32x4' }, // frame rect
            ],
          },
        ],
      },
      fragment: {
        entryPoint: 'tile_fs',
        module,
        targets: [{
          format: presentationFormat,
          blend: {
            color: {
              srcFactor: 'src-alpha',
              dstFactor: 'one-minus-src-alpha',
              operation: 'add',
            },
            alpha: {
              srcFactor: 'one',
              dstFactor: 'one-minus-src-alpha',
              operation: 'add',
            },
          },
        }],
      },
    });

    // Create tile globals uniform buffer
    tileGlobalsBuffer = device.createBuffer({
      size: 48, // 12 floats minimum for WebGPU
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });
    
    const tileGlobals = new Float32Array(12);
    tileGlobals[0] = atlasWidth;
    tileGlobals[1] = atlasHeight;
    tileGlobals[2] = GAME_WIDTH;
    tileGlobals[3] = GAME_HEIGHT;
    for (let i = 4; i < 12; i++) {
      tileGlobals[i] = 0.0;
    }
    device.queue.writeBuffer(tileGlobalsBuffer, 0, tileGlobals);

    // Create tile bind group
    tileBindGroup = device.createBindGroup({
      layout: tilePipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: spriteSampler },
        { binding: 1, resource: spriteTextureView },
        { binding: 2, resource: { buffer: tileGlobalsBuffer } },
      ],
    });

    // Load world data
    const worldData = await fetch(WORLD_DATA_URL).then(r => r.json());
    mapManager = new MapManager(worldData);
    currentRoomX = worldData.startRoomX || 1;
    currentRoomY = worldData.startRoomY || 1;
    mapManager.currentRoomX = currentRoomX;
    mapManager.currentRoomY = currentRoomY;

    await initializeDevTools();

    // Build initial tile buffer
    rebuildCurrentRoomTiles();

    atlasLoaded = true;
    console.log('WebGPU initialized');
    return true;
  } catch(error) {
    console.error('WebGPU initialization failed:', error);
    return false;
  }
}

async function initializeDevTools() {
  if (!DEV_TOOLS_ENABLED) {
    const editorUI = document.getElementById('editor-ui');
    if (editorUI) {
      editorUI.remove();
    }
    devToolsInitialized = true;
    return;
  }

  if (devToolsInitialized) {
    return;
  }

  const module = await import('./level-editor.js');
  const { LevelEditor } = module;
  levelEditor = new LevelEditor(canvas, mapManager, rebuildCurrentRoomTiles, {
    tileSize: TILE_WIDTH,
    statusUpdateCallback: updateEditorStatus,
    onNpcClick: handleNpcEditorClick,
  });
  devToolsInitialized = true;
  updateEditorStatus();
  console.log('Level editor initialized (dev tools enabled)');
}

// Build tile instance buffer for current room
function rebuildCurrentRoomTiles() {
  if (!mapManager || !device || !atlasData) return;

  const map = mapManager.getCurrentMap();
  if (!map || !Array.isArray(map.tileData)) {
    console.warn(`No tile data for room (${currentRoomX}, ${currentRoomY})`);
    return;
  }
  const tileData = map.tileData;
  const tiles = atlasData.tiles;
  const tileLookup = new Map(tiles.map((t) => [t.id, t]));

  // Send tile data to WASM for collision detection
  if (wasm && wasm.SetTileData) {
    // Flatten the 2D array into a 1D array
    const flatTiles = new Int32Array(ROOM_TILE_COLS * ROOM_TILE_ROWS);
    for (let row = 0; row < tileData.length && row < ROOM_TILE_ROWS; row++) {
      for (let col = 0; col < tileData[row].length && col < ROOM_TILE_COLS; col++) {
        flatTiles[row * ROOM_TILE_COLS + col] = tileData[row][col];
      }
    }

    // Allocate memory in WASM, copy data, call function
    // Use a safe memory offset that won't conflict with game memory
    const memOffset = 512 * 1024; // 512KB offset
    const tilePtr = memOffset;
    const memory = new Int32Array(wasm.memory.buffer);
    for (let i = 0; i < flatTiles.length; i++) {
      memory[(tilePtr / 4) + i] = flatTiles[i];
    }

    wasm.SetTileData(tilePtr, ROOM_TILE_COLS, ROOM_TILE_ROWS);

    // Debug: Verify tiles were received correctly in WASM
  }

  sendCurrentRoomNpcData();
  
  // Build instance data: each tile is 6 floats (x, y, frameX, frameY, frameW, frameH)
  const instances = [];
  
  const maxRows = Math.min(tileData.length, ROOM_TILE_ROWS);
  for (let row = 0; row < maxRows; row++) {
    const maxCols = Math.min(tileData[row].length, ROOM_TILE_COLS);
    for (let col = 0; col < maxCols; col++) {
      const tileId = tileData[row][col];
      if (tileId === 0) continue; // Skip empty tiles
      
      const tileInfo = tileLookup.get(tileId);
      if (!tileInfo) continue;
      
      const x = col * TILE_WIDTH;
      const y = row * TILE_HEIGHT;
      
      instances.push(
        x, y,  // tile position
        tileInfo.x, tileInfo.y, tileInfo.width, tileInfo.height  // frame rect
      );
    }
  }

  // Render a visual seam using the next room's top row while keeping collisions unchanged
  if (verticalRemainder > 0) {
    const partialHeight = verticalRemainder;
    const nextRoom = mapManager.getRoom(currentRoomX, currentRoomY + 1);
    if (nextRoom && nextRoom.length > 0) {
      const nextRow = nextRoom[0] || [];
      const partialY = ROOM_TILE_ROWS * TILE_HEIGHT;
      const maxCols = Math.min(nextRow.length, ROOM_TILE_COLS);
      for (let col = 0; col < maxCols; col++) {
        const tileId = nextRow[col] ?? 0;
        if (tileId === 0) continue;
        const tileInfo = tileLookup.get(tileId);
        if (!tileInfo) continue;
        const x = col * TILE_WIDTH;
        instances.push(
          x, partialY,
          tileInfo.x, tileInfo.y, tileInfo.width, partialHeight
        );
      }
    }
  }
  
  tileInstanceCount = instances.length / 6;
  
  if (tileInstanceCount > 0) {
    const instanceData = new Float32Array(instances);
    
    if (tileInstanceBuffer) {
      tileInstanceBuffer.destroy();
    }
    
    tileInstanceBuffer = device.createBuffer({
      size: instanceData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
    });
    
    device.queue.writeBuffer(tileInstanceBuffer, 0, instanceData);
  }
  
  updateEditorStatus();
}

function sendCurrentRoomNpcData() {
  if (!mapManager || !wasm || !wasm.SetNpcData) {
    return;
  }

  if (!wasm.memory || !wasm.memory.buffer) {
    return;
  }

  const npcList = mapManager.getCurrentNpcs ? mapManager.getCurrentNpcs() : [];
  const count = Math.min(npcList.length, MAX_NPCS_PER_ROOM);
  if (npcList.length > MAX_NPCS_PER_ROOM) {
    console.warn(`NPC list truncated to ${MAX_NPCS_PER_ROOM} entries for room (${currentRoomX}, ${currentRoomY}).`);
  }
  const npcBuffer = new Int32Array(wasm.memory.buffer, NPC_MEMORY_OFFSET, MAX_NPCS_PER_ROOM * 2);
  npcBuffer.fill(0);

  for (let i = 0; i < count; i++) {
    const spawn = npcList[i] || { col: 0, row: 0 };
    npcBuffer[i * 2] = spawn.col ?? 0;
    npcBuffer[i * 2 + 1] = spawn.row ?? 0;
  }

  wasm.SetNpcData(currentRoomX, currentRoomY, NPC_MEMORY_OFFSET, count);
  lastRoomSent = `${currentRoomX},${currentRoomY}`;
  lastNpcCount = count;
  if (DEV_TOOLS_ENABLED) {
    let wasmCount = -1;
    if (typeof __educeWasm !== 'undefined' && __educeWasm.GetNpcCount) {
      wasmCount = __educeWasm.GetNpcCount();
    }
    console.log(`Sent ${count} NPC spawns to WASM for room (${currentRoomX}, ${currentRoomY}) -> wasm reports ${wasmCount}`);
  }
}

function handleNpcEditorClick({ worldX, worldY }) {
  if (!mapManager || !wasm) {
    return false;
  }

  const { GetNpcCount, GetNpcX, GetNpcY } = wasm;
  if (typeof GetNpcCount !== 'function' || typeof GetNpcX !== 'function' || typeof GetNpcY !== 'function') {
    return false;
  }

  const npcCount = GetNpcCount();
  if (!npcCount || npcCount <= 0) {
    return false;
  }

  const width = characterFrameWidth;
  const height = characterFrameHeight;

  for (let index = npcCount - 1; index >= 0; index--) {
    const npcX = GetNpcX(index);
    const npcY = GetNpcY(index);
    if (worldX >= npcX && worldX <= npcX + width &&
        worldY >= npcY && worldY <= npcY + height) {
      const removed = mapManager.removeNpcByIndex(mapManager.currentRoomX, mapManager.currentRoomY, index);
      if (removed) {
        rebuildCurrentRoomTiles();
        return true;
      }
      return false;
    }
  }

  return false;
}

// Update editor status UI
function updateEditorStatus() {
  const editorUI = document.getElementById('editor-ui');
  const selectedTileSpan = document.getElementById('selected-tile');
  const editorModeSpan = document.getElementById('editor-mode');
  const npcCountSpan = document.getElementById('room-npc-count');
  const wasmNpcSpan = document.getElementById('wasm-npc-count');
  const npcDebugSpan = document.getElementById('npc-debug');
  
  if (!editorUI || !selectedTileSpan) {
    return;
  }

  if (!DEV_TOOLS_ENABLED) {
    editorUI.style.display = 'none';
    return;
  }

  if (levelEditor && levelEditor.isEditorMode) {
    editorUI.style.display = 'block';
    if (levelEditor.editMode === 'tiles') {
      selectedTileSpan.textContent = levelEditor.selectedTileId;
    } else {
      selectedTileSpan.textContent = 'NPC';
    }
    if (editorModeSpan) {
      editorModeSpan.textContent = levelEditor.editMode === 'tiles' ? 'Tiles' : 'NPCs';
    }
    if (npcCountSpan && mapManager) {
      npcCountSpan.textContent = mapManager.getNpcCount ? mapManager.getNpcCount() : 0;
    }
    if (wasmNpcSpan && typeof __educeWasm !== 'undefined' && __educeWasm.GetNpcCount) {
      wasmNpcSpan.textContent = __educeWasm.GetNpcCount();
    }
    if (npcDebugSpan) {
      const debugPieces = [];
      debugPieces.push(`local:${mapManager ? mapManager.getNpcCount() : 0}`);
      debugPieces.push(`sent:${lastNpcCount} @ ${lastRoomSent}`);
      if (typeof __educeWasm !== 'undefined' && __educeWasm.GetNpcCount) {
        debugPieces.push(`wasm:${__educeWasm.GetNpcCount()}`);
      } else {
        debugPieces.push('wasm:n/a');
      }
      npcDebugSpan.textContent = debugPieces.join(' | ');
    }
  } else {
    editorUI.style.display = 'none';
  }
}

// Check for room changes
function checkRoomChange() {
  if (!wasm) return;
  
  const newRoomX = wasm.GetPlayerRoomX();
  const newRoomY = wasm.GetPlayerRoomY();

  if (initialNpcSyncPending) {
    if (mapManager) {
      mapManager.currentRoomX = currentRoomX;
      mapManager.currentRoomY = currentRoomY;
      rebuildCurrentRoomTiles();
    }
    initialNpcSyncPending = false;
  }
  
  if (newRoomX !== currentRoomX || newRoomY !== currentRoomY) {
    currentRoomX = newRoomX;
    currentRoomY = newRoomY;
    
    if (mapManager) {
      mapManager.currentRoomX = currentRoomX;
      mapManager.currentRoomY = currentRoomY;
      rebuildCurrentRoomTiles();
    }
    
    console.log(`Room changed to (${currentRoomX}, ${currentRoomY})`);
  }
}

function renderScene() {
  if (!atlasLoaded || !wasm || !device) return;

  const frames = atlasData[CHARACTER_ANIMATION];
  if (!frames || frames.length === 0) return;

  const characters = [];

  const getNpcCount = wasm.GetNpcCount;
  const getNpcX = wasm.GetNpcX;
  const getNpcY = wasm.GetNpcY;
  const getNpcFrame = wasm.GetNpcFrame;
  const getNpcFacing = wasm.GetNpcFacing;

  if (typeof getNpcCount === 'function' && typeof getNpcX === 'function' && typeof getNpcY === 'function') {
    const npcCount = getNpcCount();
    for (let i = 0; i < npcCount; i++) {
      const frameIndex = typeof getNpcFrame === 'function' ? getNpcFrame(i) : 0;
      const frame = frames[frameIndex % frames.length];
      characters.push({
        x: getNpcX(i),
        y: getNpcY(i),
        facing: typeof getNpcFacing === 'function' ? getNpcFacing(i) : 1,
        frame
      });
    }
  }

  const playerFrameIndex = wasm.GetCurrentFrame();
  const playerFrame = frames[playerFrameIndex % frames.length];
  characters.push({
    x: wasm.GetPlayerX(),
    y: wasm.GetPlayerY(),
    facing: wasm.GetPlayerFacing(),
    frame: playerFrame
  });

  const encoder = device.createCommandEncoder({ label: 'render-encoder' });
  const pass = encoder.beginRenderPass({
    label: 'render-pass',
    colorAttachments: [
      {
        view: gpuContext.getCurrentTexture().createView(),
        loadOp: 'clear',
        clearValue: [0.39, 0.58, 0.93, 1],
        storeOp: 'store',
      },
    ],
  });

  if (tileInstanceCount > 0 && tileInstanceBuffer) {
    pass.setPipeline(tilePipeline);
    pass.setBindGroup(0, tileBindGroup);
    pass.setVertexBuffer(0, tileInstanceBuffer);
    pass.draw(6, tileInstanceCount);
  }

  if (characters.length > 0) {
    pass.setPipeline(pipeline);
    const maxRenderable = Math.min(characters.length, characterBindGroups.length);
    if (characters.length > maxRenderable && DEV_TOOLS_ENABLED) {
      console.warn(`Character render capped at ${maxRenderable} instances (have ${characters.length})`);
    }

    for (let i = 0; i < maxRenderable; i++) {
      const character = characters[i];
      const frame = character.frame;
      if (!frame) continue;

      characterUniformData[0] = frame.x;
      characterUniformData[1] = frame.y;
      characterUniformData[2] = frame.width;
      characterUniformData[3] = frame.height;
      characterUniformData[4] = atlasWidth;
      characterUniformData[5] = atlasHeight;
      characterUniformData[6] = character.x;
      characterUniformData[7] = character.y;
      characterUniformData[8] = GAME_WIDTH;
      characterUniformData[9] = GAME_HEIGHT;
      characterUniformData[10] = character.facing;
      characterUniformData[11] = 0.0;

      device.queue.writeBuffer(characterUniformBuffers[i], 0, characterUniformData);
      pass.setBindGroup(0, characterBindGroups[i]);
      pass.draw(6);
    }
  }

  pass.end();
  device.queue.submit([encoder.finish()]);
}

//
// WASM initialization
//

async function init() {
  try {
    console.log('Loading WASM...');
    
  const response = await fetch(WASM_URL);
    const { instance } = await WebAssembly.instantiateStreaming(response);
    
  wasm = instance.exports;
  globalThis.__educeWasm = wasm;
    memory = wasm.memory;
    
    console.log('WASM loaded');
    
    wasm.WebInit(GAME_WIDTH, GAME_HEIGHT, 4);
    console.log('Game initialized');
    
    // Initialize WebGPU
    const gpuOk = await initWebGPU();
    if (!gpuOk) {
      throw new Error('WebGPU required but not available');
    }
    
    lastTime = performance.now();
    gameLoop(lastTime);
    
    console.log('Game loop started');
    
    // Start background music on first user interaction
    document.addEventListener('click', () => {
      playMidiSong(true); // Loop enabled
      setMasterVolume(0.3); // Set volume to 30%
    }, { once: true });
    
    console.log('Click anywhere to start music');
  } catch(error) {
    console.error('Failed to initialize:', error);
    document.body.innerHTML = `<div style="color: white; padding: 20px;">
      <h1>Error loading game</h1>
      <pre>${error.message}</pre>
    </div>`;
  }
}

// Menu System Event Handlers
function setupMenuHandlers() {
  const gameMenu = document.getElementById('game-menu');
  const resumeBtn = document.getElementById('resume-btn');
  const playMidiBtn = document.getElementById('play-midi');
  const stopMidiBtn = document.getElementById('stop-midi');
  const bgmVolumeSlider = document.getElementById('bgm-volume');
  const bgmVolumeDisplay = document.getElementById('bgm-volume-display');
  const bgmVolUpBtn = document.getElementById('bgm-vol-up');
  const bgmVolDownBtn = document.getElementById('bgm-vol-down');
  const sfxVolumeSlider = document.getElementById('sfx-volume');
  const sfxVolumeDisplay = document.getElementById('sfx-volume-display');
  const sfxVolUpBtn = document.getElementById('sfx-vol-up');
  const sfxVolDownBtn = document.getElementById('sfx-vol-down');
  
  let isMenuOpen = false;

  // Apply initial slider values to audio system
  const initialBgmVolume = parseInt(bgmVolumeSlider.value, 10);
  const initialSfxVolume = parseInt(sfxVolumeSlider.value, 10);
  setBgmVolume(initialBgmVolume / 100);
  setSfxVolume(initialSfxVolume / 100);
  bgmVolumeDisplay.textContent = `BGM: ${initialBgmVolume}%`;
  sfxVolumeDisplay.textContent = `SFX: ${initialSfxVolume}%`;
  
  // Toggle menu with ESC key
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      // Don't toggle menu if in editor mode
      if (levelEditor && levelEditor.isEditorMode) {
        return;
      }
      
      isMenuOpen = !isMenuOpen;
      gameMenu.style.display = isMenuOpen ? 'block' : 'none';
      if (isMenuOpen) {
        const currentBgm = Math.round(getBgmVolume() * 100);
        const currentSfx = Math.round(getSfxVolume() * 100);
        bgmVolumeSlider.value = currentBgm;
        sfxVolumeSlider.value = currentSfx;
        bgmVolumeDisplay.textContent = `BGM: ${currentBgm}%`;
        sfxVolumeDisplay.textContent = `SFX: ${currentSfx}%`;
      }
      e.preventDefault();
    }
  });
  
  // Resume button
  resumeBtn.addEventListener('click', () => {
    isMenuOpen = false;
    gameMenu.style.display = 'none';
  });
  
  // Play music button
  playMidiBtn.addEventListener('click', () => {
    playMidiSong(true);
  });
  
  // Stop music button
  stopMidiBtn.addEventListener('click', () => {
    stopMidiSong();
  });
  
  // BGM Volume slider
  bgmVolumeSlider.addEventListener('input', (e) => {
    const volume = parseInt(e.target.value, 10);
    bgmVolumeDisplay.textContent = `BGM: ${volume}%`;
    setBgmVolume(volume / 100);
  });
  
  // BGM Volume + button
  bgmVolUpBtn.addEventListener('click', () => {
    let volume = parseInt(bgmVolumeSlider.value, 10);
    volume = Math.min(100, volume + 10);
    bgmVolumeSlider.value = volume;
    bgmVolumeDisplay.textContent = `BGM: ${volume}%`;
    setBgmVolume(volume / 100);
  });
  
  // BGM Volume - button
  bgmVolDownBtn.addEventListener('click', () => {
    let volume = parseInt(bgmVolumeSlider.value, 10);
    volume = Math.max(0, volume - 10);
    bgmVolumeSlider.value = volume;
    bgmVolumeDisplay.textContent = `BGM: ${volume}%`;
    setBgmVolume(volume / 100);
  });
  
  // SFX Volume slider
  sfxVolumeSlider.addEventListener('input', (e) => {
    const volume = parseInt(e.target.value, 10);
    sfxVolumeDisplay.textContent = `SFX: ${volume}%`;
    setSfxVolume(volume / 100);
  });
  
  // SFX Volume + button
  sfxVolUpBtn.addEventListener('click', () => {
    let volume = parseInt(sfxVolumeSlider.value, 10);
    volume = Math.min(100, volume + 10);
    sfxVolumeSlider.value = volume;
    sfxVolumeDisplay.textContent = `SFX: ${volume}%`;
    setSfxVolume(volume / 100);
  });
  
  // SFX Volume - button
  sfxVolDownBtn.addEventListener('click', () => {
    let volume = parseInt(sfxVolumeSlider.value, 10);
    volume = Math.max(0, volume - 10);
    sfxVolumeSlider.value = volume;
    sfxVolumeDisplay.textContent = `SFX: ${volume}%`;
    setSfxVolume(volume / 100);
  });
  
  console.log('Menu handlers initialized');
}

init();
setupMenuHandlers();
</script>
</body>
</html>
